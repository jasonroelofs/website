---
title: "What's Next?"
date: 2021-03-02T12:00:00-05:00
draft: false
---

It has been some time since I last wrote about technology and specifically about software development. I've been professionally developing software for just over fifteen years, for multiple startups, as a consultant, and currently at [Stripe](https://stripe.com) building tooling and processes for making our internal services and Stripe as a whole more reliable. I can map over my career how my skills and methodologies of developing software has improved, but there is one question throughout my career that continues to bug me: What's next?

Now, this isn't a "What's next for me?" but "What's next in software and computing as a whole?". Don't get me wrong, computing is an amazing field to be a part of. The capabilities we have today were unfathomable even 10 or 20 years ago, much less when our field started back in the 50s and 60s! We have access to a huge and increasing breadth of tools to solve problems across all fields and walks of life and in the past ten years we have seen a new wave of great programming languages such as Go, Rust, Elixir, and TypeScript (feel free to replace with your preferred list!). These languages let us build faster, more scalable, safer software, faster, than we've ever been able to before.

So what's the problem? As odd as it may sound, I can't help but feel that our field has stagnated. For all of the people playing around with programming languages (including [yours truly](https://github.com/jasonroelofs/language)) we have not seen nor found the next leap, the next major improvement that lets us think, process, and go even further with computers. When we dive into the [history of programming languages](https://en.wikipedia.org/wiki/History_of_programming_languages), we can see that every major paradigm in software, from procedural and imperative languages, through object-oriented, purely functional, and logical was all fleshed out and well understood by 1980, over 40 years ago. Every language since then has combined and/or improved upon these paradigms in different ways and I've yet to see any language today that makes me think "huh, there's something new here."

And if even the legendary Alan Kay, the inventor of Object-oriented programming and the SmallTalk language, who spent 16 years researching new paradigms through the [Viewpoints Research Insitute](http://www.vpri.org/) didn't find it (though the papers and the research they did do is amazing and worth familiarizing yourself with), you start to wonder if there is a next step at all.

Or maybe I'm looking in the wrong direction. Maybe the next step isn't going to come from programming language research at all.

Delving deeper into our field's history, you'll eventually come across a little thing called the [Dynabook](https://en.wikipedia.org/wiki/Dynabook), invented by Alan Kay, a device intended to make computing so easy and intuitive to use that it would be a fundamental educational tool, making computing accessible to all. While Steve Jobs and the iPhone and iPad were heavily influenced by this idea, it's easily argued that Jobs missed the entire point of the Dynabook, building a device for consumption instead of education.

Millions of people today carry around computational devices in their pockets that puts even the mighty Cray supercomputers of the 90s to shame, and yet the true power of these devices is locked away. We rely on others to build the apps we use, whether they be for productivity, education, or consumption (e.g. games, videos, and music). For the vast majority of people, there's no other way to use these or other devices. Even for those of us who understand software and computing, it's still significantly harder than it (in my opinion) should be to make a computer do what you want.

Well, that's all true except for one paradigm described way back in 1961 that exploded into popularity in 1979: the [Spreadsheet](https://en.wikipedia.org/wiki/Spreadsheet). Whether it's Numbers on a Mac, Microsoft Excel, or Google Spreadsheets, no tool has made computing more accessible to everyone than the spreadsheet. Its paradigm is almost completely intuitive: enter in data, compute on that data. It's so useful that even the largest companies in the world still rely on spreadsheets to keep track of and run calculations on vital information. Not only that, but the spreadsheet is so intuitive that it's the go-to for nigh anyone who wants to track something on their computer! I've talked with countless people who would say that computers make them feel dumb but yet they can and do build the most elaborate programs purely in a spreadsheet.

Granted, there are plenty of problems with spreadsheets when it comes to computability, namely being that the more elaborate a spreadsheet becomes, the less maintainble it is. But even so, nothing in 40 years has ever come close to displacing the spreadsheet as the computational tool of choice for the masses. Why? Because of a fundamental difference in paradigms:

* Software starts at the logical layer, with data being secondary.
* Spreadsheets starts at the data layer, with logic being secondary.

Or to put it in another way, spreadsheets take what people already have and/or know, the data, and then expose tools to manipulate that data in real time. Almost all software stacks, however, (key exceptions being environments like SmallTalk) require a 'build-and-teardown' the world to try out every change, a paradigm that I'm sick of. To quote [Bret Victor](http://worrydream.com/#!/LearnableProgramming) "But there is no future in destroy-the-world programming."

What makes this more frustrating is that this discussion is also decades old. Seymour Papert wrote his dissertation on computing as an educational topic, a book that is now considered one of the most influential in Computer Science, spawned the idea of [Turtle graphics](https://en.wikipedia.org/wiki/Turtle_(robot)) and even a whole line of robotic Legos with the same name: [Mindstorms](https://en.wikipedia.org/wiki/Mindstorms_(book)).

This article is the first of many in which I will explore this problem, in a way that may seem strange, but I recently fell into the perfect project for this kind of research. What exactly I want to build will be for future articles, but for now, I want to see what's on the [other tree branch](http://worrydream.com/Links2013/) (Reading Tip #3). However, I think Bret actually got something wrong in his statement here. I think we can build a graft from the branch we're currently on to the other branch, and find a way to move forward without having to backtrack.
