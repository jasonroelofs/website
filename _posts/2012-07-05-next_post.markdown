---
layout: post
title: Abstract Persistence Logic
published: true
series: Designing a Rails App
tags:
  - software
  - design
  - persistance
  - raidit
---

I've come to realize over my years of Rails development that there's nothing more painful than a slow test suite. Slow tests encourage you to not run them as often and make it difficult to stay diligent and focused on TDD. When tests are slow (and by slow I mean greater than one or two seconds to run an individual test), development slows down, and when that slows down distractions appear to feed on the free time.

How do you keep a test suite fast? You can make sure to only load in what you need (ala not Rails, as anyone who has a 15s load time Rails app can attest), but nothing slows down overall test execution worse than communication with an external service, like your database of choice. Tests that run purely in memory are the fastest tests possible.

Choosing a persistence layer at the start of a project is almost always a mistake in multiple ways. As every persistence library has well known pros and cons, making a decision without understanding the domain model of your application ensures you will have issues later on when your data needs don't match the storage of said data. On top of this, any choice you make now is a choice that cannot be made or deferred to later, resulting in a suboptimal architecture especially if you follow The Rails Way and sprinkle ActiveRecord code all throughout your app. Don't make decisions now that will be difficult, if not impossible, to fix later on. As a minor but related point, persistence is not your application, so make application-level decisions first and anything extra later. As Uncle Bob says, good architecture is the maximization of decisions **not** made.

It's not hard to find many different patterns developed over decades that solve this problem in a myriad of different ways and for all sorts of different systems and languages. Most of the best can be found in Martin Fowler's book [Patterns of Enterprise Application Architecture](http://martinfowler.com/books/eaa.html). The two I spent the most time investigating are the [Repository](http://martinfowler.com/eaaCatalog/repository.html) and [Data Mapper](http://martinfowler.com/eaaCatalog/dataMapper.html) as well as a number of existing Ruby libraries implementing these patterns.

The pattern I chose needed to fit two criteria: needs to be simple to implement and it needs to be pluggable, allowing me to have an in-memory implementation as well as for whatever persistence tool I end up using. DataMapper, like ActiveRecord, hides away persistence logic behind the domain model itself and is meant to be a layer you never have to think too much about, it just works behind the scenes. I did not want this type of library as it puts too much persistence logic in the model itself and would be difficult to abstract out an in-memory implementation.

Thus I went with a minimal implementation of the Repository pattern. I have a top level Repository object that handles the mapping between models and persistence logic with the models being kept free of any knowledge that they are being persisted. While Fowler's pattern recommends any Repository object include a full query language of it's own (e.g. Hibernate's HQL), all I needed was a decoupled mapping between an model, like User, to it's persistence logic. As such I came up with the following:

<pre><code data-language="ruby">
class Repository

  ##
  # Add mapping(s) to this repository. This will add to the existing known
  # set of mappings. To start the mapping list anew, use +.reset!+ first.
  ##
  def self.configure(options = {})
    @mappings ||= {}
    @mappings.merge!(options)
  end

  ##
  # Clear out all known mappings
  ##
  def self.reset!
    @mappings = {}
  end

  ##
  # Find the defined mapping for the given Domain Model class
  ##
  def self.for(klass)
    @mappings[klass] || @mappings[klass.to_s]
  end

end
</code></pre>

It's usage is equally simple. First define how the classes map to their persistence:

<pre><code data-language="ruby">
  # Using strings here so that there isn't a hard dependency on
  # the class itself.
  Repository.configure(
    "User"        => InMemory::UserRepo.new,
    "Guild"       => InMemory::GuildRepo.new,
    "Character"   => InMemory::CharacterRepo.new,
    "Raid"        => InMemory::RaidRepo.new,
    "Signup"      => InMemory::SignupRepo.new,
    "Permission"  => InMemory::PermissionRepo.new
  )
</code></pre>

then request the persistence object whenever persistence is needed, for example:

<pre><code data-language="ruby">
  user = User.new
  Repository.for(User).save(user)
</code></pre>

This setup has a number of benefits outside of the decoupling of modes and persistence. With this layer, I'm able to have multiple implementations of persistence sitting right next to each other without problems. As the models don't know anything about the Repository objects I'm guarenteed to not have any persistence details leak out into the app. This also opens up the possibility of using different persistence for different models, if it comes to needing that. On top of all this, as I develop the application using purely in-memory persistence, I'll be evolving a full persistence API for raidit, documenting how to implement any other type of persistence.

You can see the current implementation of the various in-memory repositories in [app/repositories/in_memory.rb](https://github.com/jasonroelofs/raidit/blob/master/app/repositories/in_memory.rb). You can also follow along on a gist I'll be continuously updating with full test suite timing runs here: [https://gist.github.com/2886208](https://gist.github.com/2886208).

Tests and code that runs only in memory is wicked fast. Even cucumber is fast when run this way. So stop accepting slow tests as the norm and get back to productivity. Abstract out your persistance, stop coupling every piece of your application to ActiveRecord, and get back to developing software.

