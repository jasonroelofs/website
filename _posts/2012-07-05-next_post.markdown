---
layout: post
title: Abstract Persistence Logic
published: true
series: Designing a Rails App
tags:
  - software
  - design
  - persistance
  - raidit
---

Choosing a persistence library at the start of a project is almost always a mistake. The beginning of a project is the point of highest ignorance, so why make such important and hard-to-change decisions before there's any definitive knowledge of the real needs of the application, especially since persistence is and should never be more than an implementation detail? The most important aspect of any given application is it's business rules and domain model, both of which are code. In the end, users don't care how data is persisted, but they do care that the app works as expected, so focus on that, focus on the application itself, everything else will grow from there.

There are a number of benefits to deferring this decision. First and foremost is that this deferrment ensures and requires the creation of a well defined architecture boundary between the app and any eventual persistence implementation. The API that evolves from this effort makes the enventual persistence requirement trivial to add to the project and also trivial to make major changes to later. Secondly, because persistence is deferred, and because every application needs data, the first "persistence" implementation is simply in-memory. This makes the code, and more importantly the tests, extremely fast.

Rails, unfortunately, does not make this easy for us. It wants us to use ActiveRecord and it wants us to not care where we let ActiveRecord code slip in (calling SQL from your views? really?). Now please note that I'm not knocking ActiveRecord itself as it's a fantastic ORM library, I'm just fed up with how coupled a Rails app gets with persistence logic and the ActiveRecord pattern does not encourage persistence decoupling at all. So, to stay away from ending up in this morass again, we need to look elsewhere for our solution.

It's not hard to find many different patterns developed over decades that solve this problem. Most of the best patterns can be found in Martin Fowler's book [Patterns of Enterprise Application Architecture](http://martinfowler.com/books/eaa.html). The two I spent the most time investigating are the [Repository](http://martinfowler.com/eaaCatalog/repository.html) and [Data Mapper](http://martinfowler.com/eaaCatalog/dataMapper.html) as well as a number of existing Ruby libraries implementing these patterns.

The pattern I chose needed to fit two criteria: simple to implement and pluggable, thus allowing me to have an in-memory implementation for development and tests as well as one for whatever persistence tool I end up using. I chose to go with Repository in raidit as DataMapper, like ActiveRecord, still adds too much knowledge of persistence to the models (e.g. User#save) and I want a clear deliniation between persistence and the application. The Repository pattern does exactly this. Because Ruby is so dynamic, implementing this pattern is very simple, and I'll show two implementations here.

**Note:** I'm implementing a very basic version of Repository. Where PoEAA talks about a Criteria system (which some have interpreted as an entire library or language, like ARel or Hibernate's HQL), I want to use nothing more complicated than method calls. I don't want any code outside of a Repository implementation knowing about how data is stored or queried.

## Repository Mapping

The first implementation, and the implementation that raidit currently uses, builds a simple object to map models to the repository implementation persisting said model. The Repository object starts off as nothing more than a few methods around a hash:

<pre><code data-language="ruby">
class Repository

  ##
  # Add mapping(s) to this repository. This will add to the existing known
  # set of mappings. To start the mapping list anew, use +.reset!+ first.
  ##
  def self.configure(options = {})
    @mappings ||= {}
    @mappings.merge!(options)
  end

  ##
  # Clear out all known mappings
  ##
  def self.reset!
    @mappings = {}
  end

  ##
  # Find the defined mapping for the given Domain Model class
  ##
  def self.for(klass)
    @mappings[klass] || @mappings[klass.to_s]
  end

end
</code></pre>

It's usage is simple. First define how the classes map to their persistence:

<pre><code data-language="ruby">
  # Using strings here so that there isn't a hard dependency on
  # the constant name itself.
  Repository.configure(
    "User"        => InMemory::UserRepo.new,
    ...
  )
</code></pre>

then request the persistence object whenever persistence is needed:

<pre><code data-language="ruby">
  user = User.new
  Repository.for(User).save user
</code></pre>

## Setting Consts

An alternate implementation that's arguably more Ruby-esque is to simply set constants to the repository objects and then use those constants directly as needed, like so:

<pre><code data-language="ruby">
  UserRepository = InMemory::UserRepo.new

  ...

  user = User.new
  UserRepository.save user
</code></pre>

Both setups have a number of benefits outside of the decoupling of persistence. Having this intermediate layer allows having multiple different implementations of persistence, even running different systems at the same time if so required. This layer also ensures that the models themselves know nothing about the persistence implementation, so I can be sure that there is no leakage of responsibilities.

You can see the current implementation of raidit's various in-memory repositories in [app/repositories/in_memory.rb](https://github.com/jasonroelofs/raidit/blob/master/app/repositories/in_memory.rb). You can also follow along on a gist I'll be continuously updating with full test suite timing runs here: [https://gist.github.com/2886208](https://gist.github.com/2886208) showing just how fast the tests run, even cucumber!

Now, once I get to the point where I know what persistence library will work best for raidit, I'll have a fully defined API for what the application needs, letting me implement only and exactly what's needed and ensuring that the tests for these objects are segregated from the rest of the app, keeping the application tests fast forever.

Refusing to make decisions now can lead to huge benefits in how the application performs, it's architecture, and maintainability. So stop writing ActiveRecord spahetti code and take control of your application before your database takes control of you, again.
